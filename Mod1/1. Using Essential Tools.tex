\documentclass{report}
\usepackage[utf8]{inputenc}

%	Changing document font to Helvetica.
\usepackage[scaled]{helvet}
\renewcommand\familydefault{\sfdefault} 
\usepackage[T1]{fontenc}

%	Changing Margins and other formatting
\usepackage{geometry}
\geometry{
	a4paper,
	total={170mm,257mm},
	left=1.5in,
	top=1in,
	right=1.5in,
	bottom=1in
}
\setlength{\parskip}{1em}

%	Source Code Highlighting
\usepackage{minted}
%	For Console
\setminted[console]{
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos,
breaklines
}
%	For Shell Scripts
\setminted[bash]{
	frame=lines,
	framesep=2mm,
	baselinestretch=1.2,
	fontsize=\footnotesize,
	linenos,
	breaklines
}

%	Pretty Tables
\usepackage{booktabs}

%	Images Support
\usepackage{graphicx}

%	Support for spaces in file names
\usepackage[space]{grffile}

\title{SysAdmin Notes for RHCSA}
\author{Somenath Sinha}
\date{August 2017}

\begin{document}
	\maketitle
	\newpage
	
	\chapter{Using Essential Tools}
	\section{Man Command}
	
	\textbf{man} followed by \textit{keyword} yields the manual page of that command. 
	\vspace{-20pt}
	\begin{minted}{console}
	$ man ls
	\end{minted}
	
	\vspace{-15pt}
	\noindent
	\textbf{man} followed by option \textbf{-k} (for keyword) and then followed by a \textit{keyword} yields a list of all the commands containing that keywork and a brief descripiton of that command.
	\vspace{-20pt} 
	\begin{minted}{console}
	$ man -k day
	daylight (3)         - initialize time conversion information
	dysize (3)           - get number of days for a given year
	daylight (3p)        - set timezone conversion information
	gettimeofday (2)     - get / set time
	gettimeofday (3p)    - get the date and time
	motd (5)             - message of the day
	Net::Time (3pm)      - time and daytime network client interface
	settimeofday (2)     - get / set time
	Time::HiRes (3pm)    - High resolution alarm, sleep, gettimeofday, interval timers
	\end{minted}
	
	\vspace{-15pt}
	\noindent
	The numbers next to the commands indicate which seciton of the man pages the command belongs to (based on their functionality). The actual section that the commands belong to can be determined by the use of 
	
	\vspace{-20pt}
	\begin{minted}{console}
	$ man man-pages
	\end{minted}
	
	\vspace{-15pt}
	\noindent
	The relevant sections for SysAdmins are Section 1, 5 \& 8. The sections are:
	
	\vspace{-5pt}
	\noindent
	\begin{tabular}{p{0.1\textwidth}p{0.25\textwidth}p{0.6\textwidth}}
		\toprule
		Section Number & Deals with & Description \\
		\midrule
		1 & Commands (Programs) & Those  commands  that  can  be executed  by the user from within a	shell. \\
		2 & System calls & Those functions which must be performed by the kernel. \\		
		3 & Library calls & Most of the libc functions. \\		
		4 & Special files (devices) & Files found in /dev. \\		
		5 & File formats and conventions & The format for /etc/passwd and other human-readable files. \\		
		6 & Games & \\		
		7 & Overview, conventions, and miscellaneous & Overviews of various topics, conventions and  protocols,  character set standards, and miscellaneous other things. \\		
		8 & System management commands & Commands like mount(8), many of which only root can execute.	\\
		\bottomrule
	\end{tabular}
	
	\noindent
	To filter down the output of the \textbf{man -k} command, we can use \textbf{grep} to obtain only the relevant parts of the result on the basis of the appropriate section number in the man-pages. 
	
	\noindent
	This can be achieved using the pipe which feeds the output of the first command to the input of the second command. 
	
	\vspace{-20pt}
	\begin{minted}{console}
	$ man -k day | grep 3
	daylight (3)         - initialize time conversion information
	dysize (3)           - get number of days for a given year
	daylight (3p)        - set timezone conversion information
	gettimeofday (3p)    - get the date and time
	Net::Time (3pm)      - time and daytime network client interface
	Time::HiRes (3pm)    - High resolution alarm, sleep, gettimeofday, interval timers
	\end{minted}
	
	\vspace{-20pt}
	\noindent
	
	\section{Understanding Globbing and Wildcards}
	\begin{tabular}{rcl}
		\textbf{*} &- &Indicates any string. \\
		\textbf{?} &- &Indicates any single character. \\
		\textbf{[$\cdots$]} &- &Indicates any character provided within brackets. \\
		\textbf{[!$\cdots$]} &- &Indicates any character \textit{NOT} provided within brackets. \\
		\textbf{[a-f]} &- &Indicates any character provided within the range of a to f. \\
	\end{tabular}
	
	\section{Understanding Globbing and Wildcards}
	\noindent
	\begin{tabular}{lcp{0.8\textwidth}}
		\textbf{\$ ls a*} &- &Lists all files and folders (including contents of each folder) that start with "a" \\
		\textbf{\$ ls *a*} &- &Lists all files and folders that contain the string "a". \\
		\textbf{\$ ls -d a*} &- &Shows all files and folders that start with "a" but excludes the contents of each individual folder. \\
		\textbf{\$ ls ??st*} &- &Lists all files and folders that have "st" as the $3^{rd}$ and the $4^{th}$ character in their name. \\
		\textbf{\$ [a-f]} &- &Indicates any character provided within the range of a to f. \\
	\end{tabular}

	\section{Understanding I/O Redirection and Pipes}
	\subsection{I/O Redirection}
	File Descriptors: 

	\noindent
	\begin{tabular}{rccclcp{0.5\textwidth}}
		\textbf{STDIN} &- &0 &- &Standard Input &- &Represents the "file" for the Standard Input Device (generally Keyboard). \\
		\textbf{STDOUT} &- &1 &- &Standard Output &- &Represents the "file" for the Standard Output Device (generally the Monitor). \\
		\textbf{STDERR} &- &2 &- &Standard Error &- &Represents the "file" for the Standard Output Device (also, generally the Monitor). \\
	\end{tabular}

	\noindent
	Redirection:
	
	\noindent
	\begin{tabular}{rclcp{0.7\textwidth}}
		\textbf{STDIN} &- &$<$ &- &Feeds the file to the right of the "<" as input to the command on the left. \\
		\textbf{STDOUT} &- &$>$ &- &Stores the output of the command to the left of the ">" to the file indicated on the right. \textit{OVERWRITES} the mentioned file.\\
		\textbf{STDOUT} &- &$>>$ &- &Stores the output of the command to the left of the "$>>$" to the file indicated on the right. \textit{APPENDS} the mentioned file.\\
		\textbf{STDERR} &- &$2>$ &- &Redirects the errors from the command mentioned on the left to the file on the right. \textit{OVERWRITES} the mentioned file.\\
	\end{tabular}
		
	\noindent
	\begin{minted}{console}	
	$ mail -s hi root < .
	$ ls > myFile
	$ ls -lh >> myFile
	$ grep hi * 2> /dev/tty6
	\end{minted}
	
	\noindent
	1 - \textit{mail} is a simple command used to send messages. The command expects the message to terminate with a ".", so we feed it directly to the command, instead of providing any input.
	
	\noindent
	4 - The STDERR is redirected to tty6 (a virtual terminal connected to the host). Can also be diverted to a file if needed, such as an errorLog.
	
	\subsection{Piping}
	The command \verb|$ ps aux| shows us the overview of all the running processes on the host. However, it's too long to view all at once. In such situations, or wherever we need to feed the output of the first command to the input of the second command, we use the pipe operator. The command would then be \verb=$ ps aux | less=.
	
	The difference in the usage of the piping and redirection operators is that Pipe is used to pass output to another program or utility, while Redirect is used to pass output to either a file or stream.
	
	\section{Using I/O Redireciton and Piping}
	
	\noindent
	\begin{minted}{console}	
	$ ps aux | awk '{print $2}'
	$ ps aux | awk '{print $2}' | sort
	$ ps aux | awk '{print $2}' | sort -n
	\end{minted}
	
	\noindent
	The second column (\$2) of the \verb|$ ps aux| command contains the Process ID (PID), and if we only want to filter the output such that only the PID is shown, we simply use the \textbf{awk} filtering utility. 
	
	If we want to sort the output of the command, we use the \textbf{sort} utility, but it generally sorts as a string. To sort the output as a number, we use the option \textbf{sort -n}.
	
	\noindent
	If you expect lots of errors for a particular command, but want to discard all errors and only see the output when successful, then simply redirect the STDERR to \verb|/dev/null|, which is a special device that discards all data written to it, i.e., a dustbin for data. 
	
	\begin{minted}{console}	
	$ find / -name "*.rpm"
	$ find / -name "*.rpm" 2> /dev/null
	\end{minted}
	
	\noindent
	The first command shows all output including errors, but the second command discards all errors and shows the rest. 	
	
	\begin{minted}{console}
	$ some_command > /dev/null 2> &1
	\end{minted}
	
	\noindent
	The above code redirects STDOUT to \verb|/dev/null| thus destroying the output, and also redirects the STDERR (2>) to STDOUT (\&1). Essentially, it discards all output - useful when we don't need the output but only need the command to execute.
	
	\begin{minted}{console}
	$ ls / > file_list.txt
	$ sort < file_list.txt > file_list_sorted.txt
	\end{minted}
	
	\noindent
	The above command stores the contents of the root directory in \textit{file\_list.txt}. Then, the second command uses both input and output redirection! The input of the sort command is fed from \textit{file\_list.txt} and the corresponding output sent to \textit{file\_list\_sorted.txt}.
	
	\chapter{Essential File Management Tools}
	\section{Understanding Linux File System Layout}
	\begin{tabular}{lcl}
		\toprule
		\textbf{root (/)} &- &Contains all other directories. \\
		\midrule
		\hspace{10pt}
		\textbf{/boot} &- &Contains everything the system needs to start up\\
		\hspace{10pt}
		\textbf{/usr} &- &Contains program files\\
		\hspace{10pt}
		\textbf{/etc} &- &Contains configuration files\\
		\hspace{10pt}
		\textbf{/home} &- &Contains a user's files\\
		\hspace{10pt}
		\textbf{/mnt} &- &Used to manually mount devices \\
		\hspace{10pt}
		\textbf{/media} &- &Devices like optical discs get auto-mounted on the media directory \\
		\bottomrule
	\end{tabular}

	\noindent
	Unlike other OSs, the linux files system is designed as such that multiple devices can be mounted on the same file system hierarchy. Thus, it's possible to mount devices remotely as well!
	
	\section{Finding Files}
	The \textbf{find} command is used to find a file within a folder and its subdirectories. When the starting point of the search is the root directory (/) then find will search the entire file system. While the utility is extremely thorough, this may cause delays due to remote devices on the network mounted on the file system. 
	
	\begin{minted}{console}
	$ find / -name "passwd"
	\end{minted}
	
	\noindent
	If you're trying to find the location of a binary file, a better command would be \textbf{which} command, as it directly shows the location of the binary, but be careful as it only works with binaries.
	
	\begin{minted}{console}
	$ which passwd
	/usr/bin/passwd
	\end{minted}
	
	\noindent
	Contrastingly, the command \textbf{whereis} not only gives us the locaiton of the binary, but the location of the complete environment of the binary!
	
	\begin{minted}{console}
	$ whereis passwd
	passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
	\end{minted}

	\noindent
	Another similar utility is called \textbf{locate} which shows all files that have the string provided to it in its name. Note, however, that locate operates on a database, that must be updated (especially after the creation of a new file) to show relevant results. 
	
	\begin{minted}{console}
	# touch sinha
	# ls
	sinha
	# locate sinha
	/usr/share/vim/vim74/keymap/sinhala-phonetic_utf-8.vim
	/usr/share/vim/vim74/keymap/sinhala.vim
	# updatedb
	# locate sinha
	/home/somu/Documents/sinha
	/usr/share/vim/vim74/keymap/sinhala-phonetic_utf-8.vim
	/usr/share/vim/vim74/keymap/sinhala.vim
	\end{minted}
	
	\section{Understanding Links}
	\textbf{inode} - An inode is a datastructure that describes a file system object such as a file or a directory, containing both the disc block locations as well as the attributes of the file system object. The inodes are identified by their inode number.
	
	\noindent
	Consequently, for us to access the files/directories, we need to be able to provide a name to the inodes, which are called hardlinks. A file may have more than one hardlink. Note that each hardlink is simply a different name provided tot he same inode. Ths, all hardlinks to the same file/directory have the same inode number. Hardlinks are one-directional only, i.e., the hardlink itself knows which inode it points to, but the inodes only know the total number of hardlinks that are associated with it, and not which exact ones are pointing to it. Since hardlinks point to some inode, they always need to stay on the same partition as the inode.
	
	\noindent
	A symbolic link on the other hand, points to a hardlink instead of an inode. As such, it has a different inode number than the one that the hardlink points to. Thus, the hardlink and symbolic link can be on different partitions as well. It can even exist across servers. Whenever a hardlink is deleted, however, all the symbolic links pointing to it are rendered invalid.
	
	\section{Working with Links}
	The \verb|ln| command is used to create both hardlinks and symbolic links. To create a symbolic link, we need only add the \verb|-s| option. The \verb|-i| option of the \verb|ls| command shows us the inode number.
	
	\begin{minted}{console}
	# ln /etc/hosts computers
	# ls -il /etc/hosts computers
	8388733 -rw-r--r--. 2 root root 158 Jun  7  2013 computers
	8388733 -rw-r--r--. 2 root root 158 Jun  7  2013 /etc/hosts
	# ln -s computers newcomputers
	# ls -il /etc/hosts computers newcomputers
	8388733 -rw-r--r--. 2 root root 158 Jun  7  2013 computers
	8388733 -rw-r--r--. 2 root root 158 Jun  7  2013 /etc/hosts
	27604468 lrwxrwxrwx. 1 root root   9 Sep  7 19:26 newcomputers -> computers
	# rm -f computers
	# ls -il /etc/hosts newcomputers
	8388733 -rw-r--r--. 1 root root 158 Jun  7  2013 /etc/hosts
	27604468 lrwxrwxrwx. 1 root root   9 Sep  7 19:26 newcomputers -> computers
	# exit
	exit
	$ ln /etc/shadow mydata
	ln: failed to create hard link ‘mydata’ => ‘/etc/shadow’: Operation not permitted
	$ ls -l /etc/shadow
	----------. 1 root root 1375 Sep  5 21:04 /etc/shadow
	\end{minted}
	When the hardlink \textit{computers} to the inode associated with \texttt{/etc/hosts} is deleted, the associated symbolic link of \textit{newcomputers} becomes invalid.
	
	\noindent
	Finally, RHEL 7 onwards, a user may only create a link to a file/directory that it at least has a read permission to. Thus, any user won't be able to create a link to \texttt{/etc/shadow} as it has no permissions for anybody.
	
	\section{Working with tar}
	\textbf{tar} stands for Tape Archive. The command is most commonly used to make backups of files by storing them in archives. Some of the options of \verb|tar| are:
	
	\begin{tabular}{lclcl}
		\textbf{-c} &- &create &- &typically has an extension of .tar \\
		\textbf{-t} &- &show contents &- &show contents of the archive. \\
		\textbf{-x} &- &extract & & \\
		\textbf{-z} &- &file &- &compress the archive using gzip. Typically has an extension of \verb|.tgz| \\
		\textbf{-v} &- &verbose &- &tell us what the utility is doing. \\
		\textbf{-f} &- &file &- &option to indicate the name of the archive file. \\
		\textbf{-C} &- &location &- &indicates where the archive is to be extracted. \\		
	\end{tabular}

	\begin{minted}{console}
	$ tar -cvf /root/etc.tar /etc
	\end{minted}
	
	\noindent
	The above command creates the \verb|etc.tar| archive in the \verb|/root| directory and puts the contents of \verb|/etc| in that archive. Note that the file \verb|etc.tar| has a \verb|.tar| extension only because we provided it, and not because Linux mandates it (unlike windows). Thus, sometimes we may run across tar archives that don't have an extension and are hard to detect. So, in that case we use the file command, which tells us the type of a particular file.
	
	\begin{minted}{console}
	$ file /root/etc.tar
	/root/etc.tar: POSIX tar archive (GNU)
	\end{minted}
	
	\noindent
	Note that the .tar archive only puts all the files of teh \verb|/etc| directory in the file \verb|tar.etc|, but doesn't actually compress anything. To enable compression the \verb|-z| option of the \verb|tar| command must be used. 
	
	\begin{minted}{console}
	$ tar -czf /root/etc2.tgz /etc
	\end{minted}
	
	\noindent
	Before extracting the contents of a tar file, we might want to see its contents, which can be done using the \verb|-t| option of the \verb|tar| command. \textit{NOTE: Some older versions of} \verb|tar| \textit{may require the -z option to enable working with gzip archives, even when simply using the archive and not creating it.}
	
	\begin{minted}{console}
	$ tar -tvf /root/etc2.tgz
	\end{minted}
	
	\noindent
	To actually extract the archive, we use \verb|-x| option. To indicate the location where we want the extracted files to reside, we include the \verb|-C| option. If this option is not present then the files will be extracted in the present directory. 
	
	\begin{minted}{console}
	$ tar -xvf /root/etc2.tgz -C /tmp
	\end{minted}
	
	\noindent
	To extract only one file from the archive, we can simply provide the name of the file at the very end. 
	
	\begin{minted}{console}
	$ tar -xvf /root/etc2.tgz -C / etc/wgetrc
	\end{minted}
	
	\noindent
	\textit{NOTE that in the above command, we use the relative path} \verb|etc/wgetrc| \textit{because of the fact that the archive stores a relative file path for easy extraction in any folder.}
	
	\chapter{Working with Text Files}
	\section{Understanding Regular Expressions}
	\begin{figure}[h]
		\centering
		\includegraphics[width=\linewidth]{{{D:/SysAdmin & Dev/SysAdmin/RedHat/RHCSA Complete Video Course/1. Installing RHEL Server/1.4. Working with Text Files/1.4.1 (a) RegEx Cheat Sheet}}.jpg}
		\caption{RegEx Cheat Sheet}
		\label{fig:regex-cheat-sheet}
	\end{figure}

	\section{Using common text tools}
	\subsection{cat}
	The \verb|cat| command prints the entire content of a file on to the terminal. 
	
	\subsection{less}
	Sometimes the \verb|cat| command is unsuitable, like in the case of extremely large files. In such cases, like the \verb|/var/log/messages|, the default system log file, using \verb|cat| won't work as the majority of the messages would scroll past fast. For such cases, \verb|less| is a better utility. Search functionality is exactly the same as in the case of vim. 
	
	\subsection{Head and Tail}
	\subsubsection{Head}
	The \verb|head| command by default shows us the first 10 lines of a text file. To see more or less lines, the \verb|-n| option can be used.
	
	\begin{minted}{console}
	$ head -n 20 file.txt
	\end{minted}
	
	\subsubsection{Tail}
	The \verb|tail| command by default shows us the last 10 lines of a text file. To see more or less lines, the \verb|-n| option can be used.
	
	\begin{minted}{console}
	$ tail -n 5 file.txt
	\end{minted}
	
	\subsubsection{Combination of head and tail}
	The combination of these two commands can enable the viewing of text in between specific line numbers. The command below shows lines 16-20 of \texttt{file.txt}
	
	\begin{minted}{console}
	$ head -n 20 file.txt | tail -n 5
	\end{minted}
	
	\subsection{cut}
	With the \verb|cut| utility, we can print out a specific column form a text file. It assumes the columns are separated by Tabs. Which specific column is to be printed is set by using the \verb|-f| option. For example, to only print the first column of a text file, we say:
	
	\begin{minted}{console}
	$ cut -f 1 cities
	\end{minted}
	
	\noindent
	To provide a different delimter, such as ":" we use the \verb|-d| option followed by the delimiter of our choice. 
	
	\begin{minted}{console}
	$ cut -f 1 -d : /etc/passwd
	\end{minted}
	
	\subsection{sort}
	This command sorts the input provided in the order of the ASCII table. That means numbers first, captial letters next and finally the lower case letters. 
	
	\begin{minted}{console}
	$ cut -f 1 -d : /etc/passwd | sort
	\end{minted}
	
	\noindent
	To sort on the basis of a specific criteria:
	
	\begin{tabular}{lcp{0.85\textwidth}}
		\textbf{-n} &- &Sort on the basis of actual numberical value, instead of treating a number as a string. \\
		\textbf{-f} &- &Sort in a case insensitive manner. \\
	\end{tabular}

	\subsection{tr}
	The \verb|tr| command replaces certain characters with certain other characters. Thus, it's frequently used in conjunction with pipes to modify the output of a command. 
	
	\begin{minted}{console}
	$ echo hello | tr a-z A-Z
	HELLO
	$ echo hello | tr [:lower:] [:upper:]
	HELLO
	\end{minted}
	
	\section{grep}
	\verb|grep| is a filtering utility that only prints those lines that contain a certain expression matching the pattern provided by a \textit{RegEx}.
	
	\begin{minted}{console}
	$ ps aux | grep tracker
	somu      10450  0.0  0.4 469796  9000 ?        SNl  10:06   0:00 /usr/libexec/tracker-miner-user-guides
	somu      10465  0.0  0.6 536856 12012 ?        Sl   10:06   0:00 /usr/libexec/tracker-store
	somu      10611  0.0  0.7 779816 13108 ?        SNl  10:06   0:00 /usr/libexec/tracker-extract
	somu      10614  0.0  0.5 469800  9632 ?        SNl  10:06   0:00 /usr/libexec/tracker-miner-apps
	somu      10615  0.0  0.7 710160 13204 ?        SNl  10:06   0:00 /usr/libexec/tracker-miner-fs
	root      17396  0.0  0.0 112644   968 pts/0    R+   13:49   0:00 grep --color=auto tracker
	\end{minted}
	
	\noindent
	Another use for \verb|grep| is searching files. The syntax is \verb|grep <filename-pattern> <search-directory>|.
	
	To avoid errors notifying "is a directory", simply redirect errors to \verb|/dev/null|.
	
	\begin{minted}{console}
	$ grep lisa * 2> /dev/null
	group:lisa:x:1001:
	gshadow:lisa:!::
	passwd:lisa:x:1001:1001::/home/lisa:/bin/bash
	passwd-:lisa:x:1001:1001::/home/lisa:/bin/bash
	services:na-localise     5062/tcp                # Localisation access
	services:na-localise     5062/udp                # Localisation access
	shadow:lisa:$6$0l/zSJkh$xjJNYNnj1rPs7Fq0hDWt8VucS0nLL82XrMYpmBnLF2DrzB2npFvCwxM9MJEHgCHCwvabCgEA17LK2aU0h9FIT/:17414:0:99999:7:::
	shadow-:lisa:password:17414:0:99999:7:::
	\end{minted}
	
	\subsection{wc}
	Counts the number of words, lines and characters. 
	
	\begin{tabular}{lcl}
		\textbf{-l} &- &Counts the number of lines \\
		\textbf{-w} &- &Counts the number of words \\
		\textbf{-m} &- &Counts the number of characters \\
		\textbf{-c} &- &Counts the number of bytes \\
		\textbf{-L} &- &Counts the length of the longest line \\
	\end{tabular}

	To see the number of matched lines using \verb|grep|, simply use:
	
	\begin{minted}{console}
	$ ps aux | wc
	188    2344   19581
	\end{minted}

	\subsection{grep -l}
	Grep by default returns the name of the matching file followed by the matching lines. This output can be made more readable by \verb|grep -l| which lists all the files in the directory that matches the criteria.
	
	\begin{minted}{console}
	$ grep lisa * 2> /dev/null
	group:lisa:x:1001:
	passwd:lisa:x:1001:1001::/home/lisa:/bin/bash
	services:na-localise     5062/tcp                # Localisation access
	services:na-localise     5062/udp                # Localisation access
	$ grep -l lisa * 2> /dev/null
	group
	passwd
	services
	\end{minted}
	
	\subsection{grep -i}
	The \textbf{-i} flag turns the grep command case-insensitive!
	
	\begin{minted}{console}
	$ grep lisa * 2> /dev/null
	group:lisa:x:1001:
	passwd:lisa:x:1001:1001::/home/lisa:/bin/bash
	services:na-localise     5062/tcp                # Localisation access
	services:na-localise     5062/udp                # Localisation access
	$ grep -i lisa * 2> /dev/null
	group:lisa:x:1001:
	passwd:lisa:x:1001:1001::/home/lisa:/bin/bash
	services:ltctcp          3487/tcp                # LISA TCP Transfer Channel
	services:ltcudp          3487/udp                # LISA UDP Transfer Channel
	services:na-localise     5062/tcp                # Localisation access
	services:na-localise     5062/udp                # Localisation access
	\end{minted}
	
	\subsection{grep -R}
	The usage of the \verb|-R| flag puts grep in recursive mode, where the utility searches for the file in each subfolder as well. 
	
	\begin{minted}{console}
	$ grep -iR lisa * 2> /dev/null
	group:lisa:x:1001:
	lvm/lvm.conf:	# If using external locking (type 2) and initialisation fails, with
	passwd:lisa:x:1001:1001::/home/lisa:/bin/bash
	Binary file pki/ca-trust/extracted/java/cacerts matches
	Binary file pki/java/cacerts matches
	...
	\end{minted}
	
	\subsection{grep -v}
	Grep with a \verb|-v| flag excludes the matching results. Here we can exclude the lines containing "Binary" using:
	
	\begin{minted}{console}
	$ grep -iR lisa * 2> /dev/null | grep -v Binary
	alternatives/jre_openjdk/lib/security/nss.cfg:handleStartupErrors = ignoreMultipleInitialisation
	alternatives/jre_openjdk_exports/lib/security/nss.cfg:handleStartupErrors = ignoreMultipleInitialisation
	brltty/fr-abrege.ctb:word civilisation	14-1236-16
	brltty/fr-abrege.ctb:word civilisations	14-1236-16-234
	brltty/fr-abrege.ctb:word généralisation	1245-1345-16
	brltty/latex-access.ctb:  brailleTranslator.capitalisation = "6dot"
	brltty/latex-access.ctb:      
	passwd:lisa:x:1001:1001::/home/lisa:/bin/bash
	sane.d/canon_pp.conf:# Set a default initialisation mode for each port.  Valid modes are:
	services:ltctcp          3487/tcp                # LISA TCP Transfer Channel
	services:ltcudp          3487/udp                # LISA UDP Transfer Channel
	...
	\end{minted}
	
	\section{sed and awk basics}
	\subsection{sed}
	\verb|sed| is an old utility that's used to process text. Many of it's functionalities can now be done using \verb|grep| itself. 
	
	\subsubsection{sed q}
	To see the first two lines of a file using \verb|sed| we use:
	
	\begin{minted}{console}
	$ sed 2q /etc/passwd
	root:x:0:0:root:/root:/bin/bash
	bin:x:1:1:bin:/bin:/sbin/nologin
	\end{minted}
	
	\subsubsection{sed -n}
	The \verb|-n| flag makes \verb|sed| print no output unless the \verb|p| flag is also provided. Here, we use a Regular Expression \textit{"\^root"} to match only a certain part of the text and then the \verb|p| flag to print only if that criteria is matched. 
	
	\begin{minted}{console}
	$ sed -n /^root/p /etc/passwd
	root:x:0:0:root:/root:/bin/bash
	\end{minted}
	
	The above result could also be obtained with \verb|grep "^root" /etc/passwd|.
	
	\subsubsection{Substitution with sed}
	Sed can be used to substitute text within a file using the \verb|s| parameter. It's used as :
	
	\begin{minted}{console}
	$ cat names
	Somu
	Arpi
	Neha
	Santy
	Debu
	$ sed -i 's/Santy/Dickwad/g' names
	$ cat names
	Somu
	Arpi
	Neha
	Dickwad
	Debu
	\end{minted}
	
	The \verb|-i| flag asks the modifications to be made in place. Otherwise the output (changed text) would've simply been displayed to the screen and then need to be redirected to a file for storage.
	
	\subsection{awk}
	awk is another utility that is especially useful when working with text files. It excels at operations like cutting out information.

	\subsubsection{Cutting out information using awk}
	For certain operations, the \verb|awk| command is a lot more powerful than the \verb|cut| utility. In the example below \verb|cut| has a hard time recognizing the second field, while \verb|awk| has no problem whatsoever!
	 
	\begin{minted}{console}
	$ ps aux | grep 'gdm'
	root       1117  0.0  0.1 480248  4688 ?        Ssl  09:20   0:00 /usr/sbin/gdm
	root       1333  0.8  1.2 328524 47220 tty1     Ssl+ 09:20   0:43 /usr/bin/X :0 -background none -noreset -audit 4 -verbose -auth /run/gdm/auth-for-gdm-bgrBZH/database -seat seat0 -nolisten tcp vt1
	root       1718  0.0  0.1 528944  5848 ?        Sl   09:20   0:00 gdm-session-worker [pam/gdm-password]
	gdm        1737  0.0  0.1 458088  4152 ?        Sl   09:20   0:00 ibus-daemon --xim --panel disable
	gdm        1741  0.0  0.1 373560  5424 ?        Sl   09:20   0:00 /usr/libexec/ibus-dconf
	gdm        1745  0.0  0.2 438152  7772 ?        Sl   09:20   0:00 /usr/libexec/ibus-x11 --kill-daemon
	somu      12218  0.0  0.0 112664   972 pts/0    R+   10:47   0:00 grep --color=auto gdm
	$ ps aux | grep 'gdm' | cut -f 2
	root       1117  0.0  0.1 480248  4688 ?        Ssl  09:20   0:00 /usr/sbin/gdm
	root       1333  0.8  1.2 328524 47220 tty1     Ssl+ 09:20   0:43 /usr/bin/X :0 -background none -noreset -audit 4 -verbose -auth /run/gdm/auth-for-gdm-bgrBZH/database -seat seat0 -nolisten tcp vt1
	root       1718  0.0  0.1 528944  5848 ?        Sl   09:20   0:00 gdm-session-worker [pam/gdm-password]
	gdm        1737  0.0  0.1 458088  4152 ?        Sl   09:20   0:00 ibus-daemon --xim --panel disable
	gdm        1741  0.0  0.1 373560  5424 ?        Sl   09:20   0:00 /usr/libexec/ibus-dconf
	gdm        1745  0.0  0.2 438152  7772 ?        Sl   09:20   0:00 /usr/libexec/ibus-x11 --kill-daemon
	somu      12226  0.0  0.0 112664   968 pts/0    R+   10:48   0:00 grep --color=auto gdm
	$ ps aux | grep 'gdm' | awk '{ print $2 }'
	1117
	1333
	1718
	1737
	1741
	1745
	12248
	\end{minted}
	
	\chapter{Connecting to a RHEL Server}
	\section{Connecting to a Server with SSH}
	To connect to a server we use the \verb|ssh| command. The Syntax is: \verb|ssh <server-ip>|.
	
	\begin{minted}{console}
	$ ssh 192.168.152.129
	somu@192.168.152.129's password: 
	Last login: Mon Nov 13 12:37:26 2017 from 192.168.152.128
	\end{minted}
	
	The default SSH port is \textbf{22}. To connect to SSH on a different port (common when server is exposed to the internet), is \verb|ssh -p <port-number> <server-ip>|. Note that \textit{if root login is disabled on the server,} we must also provide the username to login as. The syntax then becomes : \verb|ssh -p <port-number> <username>@<server-ip>|.
	
	\begin{minted}{console} 
	$ ssh -p 2022 sander@ldap.rhatcertification.com
	\end{minted}
	
	\section{RSA Key fingerprint and known hosts}
	Upon each new connection the ssh daemon shows us the RSA key fingerprint of the host to verify if we're connecting to the right computer. If so, the host is added to a list of known hosts permanently, in \verb|~/.ssh/known_hosts|. 
	
	When the key fingerprint of the server doesn't match the Key fingerprint on record, the system warns us from connecting! This may occur when the server has been reinstalled on the same IP address. Thus, the new key fingerprint won't match the old one. To fix this, simply remove the old entry from \verb|~/.ssh/known_hosts|.
	
	\section{sshd\_config}
	The details of the method of connection to a server is stored in the \textbf{sshd\_config} file, located in \verb|/etc/ssh/sshd_config|. 
	
	Some of the options are:
	
	\begin{tabular}{clc}
		\toprule
		\textbf{Option} &\textbf{Description} &\textbf{Default Value} \\
		\midrule
		Port	&The port number which is used for SSH on that server &22\\
		PermitRootLogin &Whether an user is allowed to login as \textit{root} user via SSH &yes \\
		\bottomrule
	\end{tabular}

	If the root login on the server via SSH is disabled, it generally makes the server a little bit more secure!
	
	\section{Understanding SSH keys}
	To initiate the ssh connection, the \textbf{SSHD} service on the server is contacted by the client. In order to confirm it's identity, the server responds with it's own \verb|/etc/ssh/ssh_host.pub| public key to the client. When the client's user has verified the key of the server, the public key fingerprint gets stored in the clients \verb|~/.ssh/known_hosts| file. Finally, the user is asked for the password to log on to the server.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{"1.5.a Server auth"}
		\caption{Server Authentication procedure}
		\label{fig:1}
	\end{figure}

	\subsection{Client authentication without password}
	The client can also prove it's identity without a password by the use of a public key that it provides to the server. The private key of the user is stored in the home directory of the user \verb|~/.ssh/id_rsa|. A packet encrypted with the private key is sent to the server which knows the user's public key. Some complex calculations based on this is performed on the authentication token sent from the client and if the identity is confirmed, then the user is logged in without needing a password.

	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{"1.5.b Client auth with no password"}
		\caption{Public Key Client Authentication without password.}
		\label{fig:1}
	\end{figure}

	\section{Using SSH Keys}
	SSH keys can be used to authenticate an user instead of a password. The private-public key pair can be generated using the \verb|ssh-keygen| utility.
	
	\begin{minted}{console}
	$ ssh-keygen
	Generating public/private rsa key pair.
	Enter file in which to save the key (/home/somu/.ssh/id_rsa): 
	Enter passphrase (empty for no passphrase): 
	Enter same passphrase again: 
	Your identification has been saved in /home/somu/.ssh/id_rsa.
	Your public key has been saved in /home/somu/.ssh/id_rsa.pub.
	The key fingerprint is:
	SHA256:0C5uEHnAgJvzFEc0ulfL1YSygT/YF5UtL9lweTfPDAc somu@vmPrime.somusysadmin.com
	The key's randomart image is:
	+---[RSA 2048]----+
	| ..==.   ooo .E. |
	|. ..++o.oo+ + o.o|
	| o.oo+++o..B . *o|
	|+ ...===. o o   +|
	| +. o +oS  .     |
	|  .. o .         |
	|      o          |
	|     .           |
	|                 |
	+----[SHA256]-----+
	\end{minted}
	
	\subsection{Copying SSH keys}
	
	The SSH keys generated on the client now have to be copied to the server which requires authentication. This can be done using \verb|ssh-copy-id|.
	
	\begin{minted}{console}
	$ ssh-copy-id 192.168.152.129
	/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
	/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
	somu@192.168.152.129's password: 
	
	Number of key(s) added: 1
	
	Now try logging into the machine, with:   "ssh '192.168.152.129'"
	and check to make sure that only the key(s) you wanted were added.
	
	$ ssh 192.168.152.129
	Last login: Wed Nov 15 11:59:03 2017 from 192.168.152.128
	\end{minted}
	
	While previous versions of \verb|ssh-copy-id| didn't support specifying a port number, RHEL 7 onwards this feature is supported. 
	
	\begin{minted}{console}
	$ ssh-copy-id -p 2022 sander@ldap.rhatcertification.com
	\end{minted}
	
	In case the public key is not recognized, it is possible to specify the public key using the \verb|ssh-copy-id -i <publicKeyFile.pub>| flag.
	
	\subsection{Copying files to a server securely using SSH}
	Files can be copied to a server using SSH connection using the \verb|scp| (secure copy) utility. 
	
	\begin{minted}{console}
	$ scp -P 22 names 192.168.152.129:~
	names                  100%   28     8.1KB/s   00:00    
	\end{minted}
	
	\noindent
	\textbf{NOTE} that the directory on which the file has to be copied to on the server, (in this case the ~ directory) has to be specified for the copy to be successful. Otherwise, \verb|scp| just creates a local copy of the file with the name of the server as the filename. 
	
	Also, if the port has to be specified, the flag is \verb|-P| which is in capital unlike \verb|ssh| and \verb|ssh-copy-id|. 
	
	\chapter{Managing Users and Groups}
	\section{Understanding the need for Users}
	User accounts are not just to ensure that different people use resources with accountability and resource management. Several processes also have to execute with permissions given to them by their respective user accounts. 
	
	For example, the \verb|apache| web server's processes and services execute under the permissions given to the \verb|apache| account. This account doesn't have root privileges, which ensures that in case of security breaches of the apache user account, the culprit doesn't gain access to any critical resources that only an administrator or the root account should have access to. 
	
	\section{User Properties}
	\subsection{Username}
	A typical user info in the \verb|/etc/passwd| file consists of the login information of several users, each with the following details :- \verb|somu:x:1000:1000:Somu:/home/somu:/bin/bash|. Here, Somu is the username, the \textit{x} in the second field references that a password has been stored for that username in the \verb|/etc/shadow| file. The file contains the (one-way) encrypted password as well as several password related information such as password expiration dates, etc. Since the \verb|/etc/shadow| file is only readable by the root user, it minimizes the security risk. Generally, only real user accounts need a password and system users (accounts used by processes to execute) don't. 
	
	\subsubsection{/etc/shadow}
	While the \verb|/etc/shadow| file contains the password of an user in an encrypted format, if the user account is new and doesn't yet have any password assigned to it, then the entry for it in /etc/shadow looks like: 
	
	\begin{minted}{console}
	$ cat /etc/shadow | grep lisa
	lisa:!!:17485:0:99999:7:::
	\end{minted} 
	
	The second entry (!!) is where the encrypted password is usually stored. The double exclamation indicates that the \textit{lisa} account hasn't set up a password yet. 
	
	\subsection{UID}
	Each user on the system is setup with a unique UserID (UID). The root has a UID of 0, and normal users start with an UID of 1000 onwards. There are a total of 64,000 UIDs available for 2.4 kernels, and 4 billion for 2.6 kernels. 
	
	\subsection{GID}
	On Linux, every user must be the member of at least one group, which is known as the \textbf{primary group} of the user, stored in the \verb|/etc/passwd| file. On RHEL, that primary group has the same name as the username and the user is the only member of that group by default (i.e., private group). The list of Groups is stored in a file called \verb|/etc/group|.
	
	\subsection{GECOS or comment field}
	This is a comment field that can contain anything the admin deems necessary. It generally contains information that makes the identification of each user easier. 
	
	\subsection{Home Directory}
	The home directory refers to the location where the user is allowed to store files. For services, this folder is important because it defines the directory where the service can read and write files. While for regular users the home directory is typically inside \verb|/home|, for services, they can be anywhere.
	
	\subsection{Default Shell}
	This is the shell (or command) that is executed on login of the user. The default value is \verb|/bin/bash|.
	
	\section{Creating and Managing Users}
	\subsection{Adding users}
	The default command for adding users on RHEL is \verb|useradd|. 
	
	\begin{tabular}{cl}
		\toprule 
		\textbf{Option} &\textbf{Description} \\
		\midrule
		\textbf{-e} &Expiration date in the format YYYY-MM-DD. Sets the date on which the user \\&account will be disabled. \\
		\textbf{-c} &Comment that sets the contents of the GECOS field. \\
		\textbf{-s} &Sets the default shell of the user. For example, a C programmer can use a \\&shell such as TCSH. \\		
		\bottomrule		
	\end{tabular}

	\begin{minted}{console}
	$ sudo useradd -c "New Test User" -s /bin/tcsh -e 2017-12-31 laura
	[sudo] password for somu: 
	$ # To verify the addition of the new user
	$ tail -n 1 /etc/passwd
	laura:x:1001:1001:New Test User:/home/laura:/bin/tcsh
	\end{minted}

	\subsubsection{id command}
	The \verb|id| command prints the real and effective user information. 
	
	\begin{minted}{console}
	$ id
	uid=1000(somu) gid=1000(somu) groups=1000(somu) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
	\end{minted}

	\section{Understanding Group Membership}
	Groups are especially useful to enable users to share files with one another. These groups may be additional groups known as secondary groups. 
	
	The \verb|/etc/passwd| file doesn't contain any reference to the secondary groups that the user is a part of, even though the \verb|/etc/group| file lists that user as a member. Thus, the best way to obtain the groups the user is a part of is by using the \verb|id| command.|
	
	\begin{minted}{console}
	$ id lisa
	uid=1002(lisa) gid=1002(lisa) groups=1002(lisa), 5009(sales)
	\end{minted}
	
	\section{Creating and Managing Groups}
	\subsection{groupadd}
	The \verb|groupadd| command is used to add a new group. 
	
	\begin{tabular}{cl}
		\toprule
		\textbf{Option} &\textbf{Description} \\
		\midrule
		\textbf{-g} &Specify the GID of the group. \\
		\bottomrule
	\end{tabular}

	\subsection{Adding users to a group}
	A user can be added to a group by directly editing the \verb|/etc/group| file, or by| using the \verb|moduser| command.
	
	\subsubsection{usermod}
	\begin{tabular}{cl}
		\toprule
		\textbf{Option} &\textbf{Description} \\
		\midrule
		\textbf{-g} &Force assign the GID as the new default group of the user.  \\
		\textbf{-G} &Erase older list of supplementary groups and assign the given groups as the \\&supplementary group of he user. \\
		\textbf{-a} &Add the given group to the list of groups for the user. \\
		\bottomrule
	\end{tabular}

	Adding a user to a group using the \verb|usermod| command is shown below. 

	\begin{minted}{console}
	$ sudo usermod -aG account laura
	$ sudo usermod -aG 5010 lisa
	$ tail -n 1 /etc/group
	account:x:5010:laura,lisa
	\end{minted}

	\section{User and Group configuration files}
	Some of the important configuration files are:
	
	\noindent
	\begin{tabular}{ll}
		\toprule
		\textbf{Option} &\textbf{Description} \\
		\midrule
		\textbf{/etc/passwd} &Contains several details of the user, other than the password.  \\
		\textbf{/etc/shadow} &Contains the password hash and password properties for the user. \\
		\textbf{/etc/group} &Contains the names of all the groups along with a list of all users \\&in them. \\
		\textbf{/etc/login.defs} &Contains the values (definitions) of several parameters used to \\&create the user, such as password max days, min days, etc.\\
		\textbf{/etc/default/useradd} &Contains the default values for several useradd parameters. \\
		\textbf{/etc/skel} &When a user's home directory is created, the contents of \\&\verb|/etc/skel| is copied there, with the appropriate group of the user.\\
		\bottomrule
	\end{tabular}

	\section{Managing Password properties}
	The user \textit{root} can manage the password properties using two commands:
	
	\subsection{passwd}
	\begin{tabular}{cl}
		\toprule
		\textbf{Option} &\textbf{Description} \\
		\midrule
		\textbf{-d} &Delete the current password. \\
		\textbf{-l} &Lock the current password. \\
		\textbf{-u} &Unlock the current password. \\
		\textbf{-e} &Expire the current password - force user to change password during next login. \\
		\textbf{-x} &Set the maximum lifetime of the password. \\
		\textbf{-n} &Set the maximum lifetime of the password. \\
		\textbf{-w} &Set days before expiration the user is warned. \\ 
		\textbf{-i} &Set days after expiration the user account becomes inactive. \\
		\bottomrule
	\end{tabular}

	\subsubsection{Locking and Unlocking passwords}
	\vspace{-10pt}
	\begin{minted}{console}
	$ sudo passwd -l laura
	Locking password for user laura.
	passwd: Success
	$ su - laura
	Password: 
	su: Authentication failure
	$ sudo cat /etc/shadow | grep laura
	laura:!!$6$0zDhsJet$q2...KRVKv8D2.:17486:0:99999:7::17531:
	$ sudo passwd -u laura
	Unlocking password for user laura.
	passwd: Success
	$ sudo cat /etc/shadow | grep laura
	laura:$6$0zDhsJet$q2...KRVKv8D2.:17486:0:99999:7::17531:
	$ su - laura
	Password: 
	Last login: Thu Nov 16 13:40:45 IST 2017 on pts/0
	$ whoami
	laura
	\end{minted}
	
	\noindent
	When an account is locked, the password hash for that user in the \verb|/etc/shadow| file is prefixed with a \verb|!!| to render it invalid and prevent authentication from succeeding (unless the root logs in as that user, which requires no password prompt).	

	\subsection{chage}
	\begin{tabular}{cl}
		\toprule
		\textbf{Option} &\textbf{Description} \\
		\midrule
		\textbf{-l} &List all password aging information. \\	
		\textbf{-E} &Set the account expiration date. \\	\textbf{-m} &Set the maximum lifetime of the password. \\
		\textbf{-M} &Set the maximum lifetime of the password. \\
		\textbf{-W} &Set days before expiration the user is warned. \\ 
		\textbf{-I} &Set days after expiration the user account becomes inactive. \\
		\bottomrule
	\end{tabular}

	\subsubsection{Setting the account expiration date}
	\vspace{-10pt}
	\begin{minted}{console}
	$ sudo chage -E 2017-12-31 laura
	[sudo] password for somu: 
	[somu@cliServer ~]$ sudo cat /etc/shadow | grep laura
	laura:$6$0zDhsJet$q2...KRVKv8D2.:17486:0:99999:7::17531:
	$ sudo chage -l laura
	Last password change                              : Nov 16, 2017
	Password expires                                  : never
	Password inactive                                 : never
	Account expires                                   : Dec 31, 2017
	Minimum number of days between password change    : 0
	Maximum number of days between password change    : 99999
	Number of days of warning before password expires : 7
	\end{minted}
	The string \textit{17531} represents the account expiration date in epoch time (seconds since Jan 1 1970).
	
	\chapter{Connecting to a LDAP Server}
	\section{Understanding LDAP}
	LDAP is an easy way to provide centralized authentication from a server. This way, many computers can be connected to a single LDAP server and the user accounts (and permissions) have to be set up only once!
	
	\textbf{LDAP} stands for \textit{Lightweight Directory Access Protocol}. It connects us to a hierarchical directory server. In the hierarchy (e.g., server.rhatcertification.com), there are top level domains such as \textit{.com}, subdomain (rhatcertification) and leaf objects (lisa). Even though the structure is similar to DNS, the notation of LDAP is different. For every container object, we write \verb|dc=<objectName>| (\textit{dc} $\rightarrow$ Domain Component) and for leaf objects, it becomes \verb|cn=<objectName>| (\textit{cn} $\rightarrow$ Common Name). The complete format then becomes \textit{cn=lisa,dc=rhatcertificaton,dc=com}.
	
	An important part of connecting to an LDAP server is the \textbf{base context}. The base context, like the search domain of DNS, is the starting point where our client should look for objects. In this case, the base context is \verb|dc=rhatcertification,dc=com|. Thus, for logging in to a server, the \textit{cn}(lisa) is searched for within the base context. 
	
	\subsection{/bin/login}
	The \verb|login| service is used whenever the user requires authentication to connect to anything. 
	
	\subsection{ldd}
	The \verb|ldd| command (List Dynamic Dependencies) prints all the shared libraries required by a program. 
	
	\begin{minted}{console}
	$ ldd /bin/login
	linux-vdso.so.1 =>  (0x00007ffc333e3000)
	libpam.so.0 => /lib64/libpam.so.0 (0x00007f85cad8a000)
	libpam_misc.so.0 => /lib64/libpam_misc.so.0 (0x00007f85cab86000)
	libaudit.so.1 => /lib64/libaudit.so.1 (0x00007f85ca95d000)
	libselinux.so.1 => /lib64/libselinux.so.1 (0x00007f85ca736000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f85ca373000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007f85ca16e000)
	libcap-ng.so.0 => /lib64/libcap-ng.so.0 (0x00007f85c9f68000)
	libpcre.so.1 => /lib64/libpcre.so.1 (0x00007f85c9d06000)
	/lib64/ld-linux-x86-64.so.2 (0x0000558e5f0bd000)
	libpthread.so.0 => /lib64/libpthread.so.0 (0x00007f85c9ae9000)
	\end{minted}
	
	\noindent
	The PAM library shown above (libpam) is akin to a plugin that adds additional functionality to the \verb|login| utility (as well as several others). PAM stands for \textit{Plugable Authentication Modules}. The configuration files for the authentication module is stored in \verb|/etc/pam.d| directory. The \verb|/etc/pam.d/login| is the configuration file for \verb|login| utility. 
	
	\subsection{PAM config file syntax}
	The PAM config files are each named after the services that require the usage of PAM. For example, the config file for the \textit{login} service is called \verb|/etc/pam.d/login|. Each file lists a bunch of rules in the syntax : \verb|<service-type> <control> <module-path> <arugments>|.
	
	\subsubsection{Service Type}
	\vspace{-10pt}
	\begin{tabular}{ll}
		\toprule
		\textbf{Service Type} &\textbf{Description} \\
		\midrule
		\textbf{auth} &Deals with user authentication via password (or other means like keys). \\	
		\textbf{account} &Non-authentication based account management. \\	
		\textbf{password} &Updating the authentication token of the user. \\
		\textbf{session} &Modules listed here are used for setup/cleanup of a service for the user. \\
		\bottomrule
	\end{tabular}

	\subsubsection{PAM Module Controls}
	\vspace{-10pt}
	\begin{tabular}{ll}
		\toprule
		\textbf{Control} &\textbf{Description} \\
		\midrule
		\textbf{requisite} &Immediately causes failure when the module returns a status that isn't 'success'. \\	
		\textbf{required} &If the service returns a non-success status, then the operation fails ultimately, \\&but only after the modules below it are invoked. This is to prevent a person with \\&malicious intent from gaining knowledge of which module failed. \\	
		\textbf{sufficient} &If a \textit{sufficient} module returns a 'success' status, the other modules below it that \\&are also a part of 'sufficient' management group will not be invoked. In case of \\&failure, another module listed 'sufficient' in the stack below it must succeed for \\&the operation to succeed. \\
		\textbf{optional} &Only causes failure if the rule stack contains only optional modules and all fail. \\
		\midrule
		\textbf{include} &For the given service type, include all lines of that type from the provided \\&configuration file. \\
		\textbf{substack} &Same as \textit{include} but when \textit{done} and \textit{die} actions are evaluated, they only cause \\&skipping of the substack. \\
		\bottomrule
	\end{tabular}
	
	The \verb|login| config file in \verb|/etc/pam.d| contains the line:
	\vspace{-10pt}
	\begin{minted}{bash}
	auth       substack     system-auth
	\end{minted}
	
	\noindent
	\textbf{NOTE} \textit{: the entry for pam\_ldap requires that the host should be able to use LDAP, which requires} \verb|pam_ldap| \textit{to be installed, and} \verb|authconfig-tui| \textit{to be executed.}
	
	The \verb|system-auth| file has rules for the common login procedure for any any process that deals with user authentication. This file in turn contains the lines :
	
	\begin{minted}{bash}
	auth        sufficient    pam_unix.so nullok try_first_pass
	...
	auth        sufficient    pam_ldap.so use_first_pass
	\end{minted}
	
	The line \verb|auth  sufficient  pam_unix.so| tells the system to look at the System login local authentication mechanism (\verb|pam_unix.so|). If that is not successful, the system is instructed to use the LDAP PAM mechanism (in \verb|pam_ldap.so|). Thus, the login process is contacting an LDAP server and trying to verify if the user account exists on that server. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{"1.6.a LDAP Authentication"}
		\caption{LDAP Authentication}
		\label{fig:1}
	\end{figure}
	
	\noindent
	Next, the LDAP configuration file (\verb|/etc/nslcd.conf|) is read, which contains the URI of the LDAP Server (\verb|ldap://server.rhatcert.com|). Finally, the client is able to connect to the LDAP server where there is a LDAP hierarchy that it can log into.  
	
	\section{Telling your server where to find the LDAP Server}
	
	\subsection{nscd}
	The Naming Service Cache Daemon needs to be installed to configure the connection of a server to an external LDAP server. It is the part of the OS that caches the information from external authentication mechanisms on the local machine.
	
	\subsection{nss-pam-ldapd}
	This sets up the local name resolution and local authentication and connects it to LDAP services. 
	
	\subsection{pam\_ldap}
	The libraries needed to make the local authentication aware of LDAP services. 
	
	\subsection{authconfig-gtk}
	\verb|authconfig| is an utility used to setup the server for external authentication. There are several variations of it, such as \verb|authconfig|, \verb|authconfig-tui| and \verb|authconfig-gtk| (GUI based).
	
	\subsubsection{LDAP Search Base DN}
	The search base DN consists of Domain Components (dc) with commas as separators. Example : \verb|dc=rhatcertification.com,dc=com|. 
	
	\subsubsection{LDAP Server}
	The server needs to have a matching certificate to the one that the client receives on connection. This is only possible with a domain name, and not an IP address. The reason for this is the server name has to match the one in the certificate and the certificate can only have one name associated to it. 
	
	\subsubsection{TLS Certificate}
	The use of a Transport Layer Security (TLS) certificate is important because unless it's used, the LDAP password is sent across the network unencrypted, which makes the entire system vulnerable. We also need to download the TLS certificate from the server (e.g., \verb|ftp://server.rhatcertification.com/pub/slapd.pem|).
	
	\subsection{Switching to an LDAP user}
	The user can switch to an LDAP user just as easily as a local user using:
	
	\begin{minted}{console}
	$ su - <ldap_username>
	\end{minted}
	
	\section{Understanding Automount}
	While it's possible to have the LDAP users use local directories on the server, generally an NFS hosts the home directories of these users. Thus, we have to automount the home directories of these users as if they're part of the local file system. 
	
	Let us consider a system where automounting is enabled, and the user wants to access a folder \verb|/data/files|. If the folder \verb|/data| is hosted on a remote file system and monitored by the automount process (called \textbf{autofs}), then there will have a file called \verb|/etc/auto.master| containing the line:
	
	\begin{minted}{bash}
	/data	/etc/auto.data
	\end{minted}
	
	The \verb|/etc/auto.master| file only shows that the automount process recognizes the \verb|/data| directory as an automount directory. This merely states that the mounting details for the data folder is present in its own file called \verb|/etc/auto.data|. That file will contain:
	
	\begin{minted}{bash}
	files	-rw		nfsServer:/data
	\end{minted}
	
	The files directory is a subdirectory of the \verb|/data| directory, and thus when the \verb|/files| directory needs to be accessed, an NFS mounting operation needs to occur, with read write access on the nfsServer's (hostname) \verb|/data| directory. Even though the user will be working on the NFS server, he/she will have no inkling of this happening behind the scene. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{"1.7.a NFS Automount"}
		\caption{NFS Automount}
		\label{fig:1}
	\end{figure}
	
	
	\subsection{Server selection for auto-mounting}
	Primarily two types of servers can accomplish the auto-mounting of home directories for LDAP users - NFS and Samba servers. In case of NFS server, the files will only be available on the local network. For access through the Internet, a Samba server has to be used. 
	
	\subsection{Samba server's CIFS protocol to automount}
	Let us consider an LDAP user \textit{ldapuser1} who has his home directory configured to \\\verb|/home/guests/ldapuser1| in his user properties. When the user logs in, there will be a system call to go to the home directory for the users, which in turn calls \verb|autofs| to mount the file system. It'll consult the \verb|/etc/auto.master| file to find:
	
	\begin{minted}{bash}
	/home/guests	/etc/auto.guests
	\end{minted}
	
	\noindent
	If anyone wants to visit that directory, the process should consult the \verb|/etc/auto.guests| file, containing the mounting details with the UNC (Universal Naming Convention) path of the actual Samba server on the internet. 
	
	\begin{minted}{bash}
	*	-fstype=cifs,username=ldapusers,password=password 
			://server.rhatcertification.com/data/&
	\end{minted}
	
	\noindent
	So, if anyone goes to \verb|*| (i.e., any directory in \verb|/data/guests|), like \verb|/home/guests/ldapuser1| or \verb|/home/guests/ldapuser2| and so on, a CIFS (Common Internet File Sharing protocol, which uses Server Message Block [SMB, Used by Samba]) mount needs to occur, specified by \verb|fstype=cifs|, with the given username and password. The address of the server is then provided. 
	
	What is of particular importance here is the matching of \verb|*| and \verb|&|. While the \verb|*| wildcard selects whatever folder the user tried to enter, the \verb|&| in the address is replaced with the corresponding text from user. Thus, if the user visits \verb|/home/guests/ldapuser1|, the \verb|*| is replaced with \verb|ldapuser1| and a matching folder is searched for on the server. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{"1.7.b Samba Automount"}
		\caption{Samba Automount}
		\label{fig:1}
	\end{figure}
	
	
	\section{Configuring Automount}
	To use automount, the \textit{automount service} in the \textbf{autofs} package needs to be installed. The primary configuration file is \verb|/etc/auto.master|. To automount the \verb|/etc/guests| folder from a Samba server, we just need to specify in the file that:
	
	\begin{minted}{bash}
	/home/guests	/etc/auto.guests
	\end{minted}
	
	Now we can add the mount options in its own individual file \textit{auto.guests}, such that quick mounting and unmounting is possible. 
	
	\subsubsection{Configuration on the Samba Server}
	The Samba server containing the \verb|data| directory needs to have the following configuration in its \verb|/etc/samba/smb.conf| :
	
	\vspace{-10pt}
	\begin{minted}{bash}
	[data]
	comment = LDAP Users' home directories
	path = /home/guests
	public = yes
	writable = no
	\end{minted}
	
	\subsection{NFS Server Automounting}
	
	In the case of a NFS mounted directory, the \textit{auto.guests} file would look like:
	
	\begin{minted}{bash}
	*	-rw	nfsServer.domain.com:/home/guests/&
	\end{minted}
	
	\noindent
	In case of either servers, the syntax remains the same. First we provide the name of the directory (\verb|*|), then the mounting options (e.g., \verb|-rw| in case of NFS) and finally the path to the real directory that has to be mounted on the local file system from that server.
	
	\section{Modifying nslcd Configuration}
	\subsection{Naming Services LDAP Client Daemon}
	The \verb|nslcd| is a service that connects the local file system to the external LDAP server. The status of the \verb|nslcd| can be checked using:
	
	\vspace{-15pt}
	\begin{minted}{console}
	$ systemctl status nslcd
	nslcd.service - Naming services LDAP client daemon.
	Loaded: loaded (/usr/lib/systemd/system/nslcd.service; enabled; vendor preset: disabled)
	Active: active (running) since Mon 2017-11-20 12:03:06 IST; 5h 59min ago
	Process: 1108 ExecStart=/usr/sbin/nslcd (code=exited, status=0/SUCCESS)
	Main PID: 1151 (nslcd)
	CGroup: /system.slice/nslcd.service
		1151 /usr/sbin/nslcd
	\end{minted}
	\vspace{-10pt}
	
	\subsubsection{/etc/nsswitch.conf}
	For every LDAP user, their identity needs to be known to the local system. This is based on the configuration stored in \verb|/etc/nsswitch.conf|. In this file, there is a line:
	
	\vspace{-15pt}
	\begin{minted}{bash}
	passwd:	files	sss	ldap
	\end{minted}
	\vspace{-10pt}
	
	This represents the order in which the sources of user account are searched for user related information. \verb|sss| is an older service no longer used by RHEL-7. Finally, it looks for the information in LDAP using \verb|nslcd|.
	
	\subsubsection{PAM using nslcd}
	PAM is responsible for the actual authentication system that ensures the LDAP server is known to the authentication mechanism. This entire process is achieved using \textit{nslcd}. 
	
	\subsection{/etc/nslcd.conf}
	This file contains the information stored by using the \verb|authconfig-gtk| command and has options to configure the \verb|nslcd| such that the LDAP server can be connected to and used. 
		
	\noindent
	\begin{tabular}{lll}
		\toprule
		\textbf{Option} &\textbf{Description} &\textbf{Example Value}\\
		\midrule
		uri &The Uniform Resource Identifier of the  &ldap://server.rhatcertification.com \\
		&LDAP Server. & \\
		base &The base context of the LDAP Server &dc=rhatcertification,dc=com \\
		ssl &Whether to use SSL/TLS. If start\_tls is &start\_tls \\
		&given, via the use of StartTLS, an & \\
		&insecure connection is upgraded to a &\\
		& secure one. &\\
		tls\_cacertdir &Location of the downloaded certificate &\verb|/etc/openldap/cacerts| \\
		&of the LDAP Server. &\\
		\bottomrule
	\end{tabular}

	In case of any problems with using LDAP, the \verb|/var/log/messages| file may contain hints that may indicate what's wrong. 
	
	\chapter{Keyboard Shortcuts}
	\begin{tabular}{lcl}
		\textbf{CTRL+U} &- &Clear Command Line. \\
		\textbf{CTRL+L} &- &Clear Screen, same as clear command. \\
	\end{tabular}
\end{document}