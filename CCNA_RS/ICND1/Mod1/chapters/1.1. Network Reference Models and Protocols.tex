\chapter{Network Reference Models and Protocols}
\section{Introduction}
When talking about the components of a network such as Network devices and protocols, it's useful to have a common frame of reference. This is provided by the OSI and TCP/IP models. These reference models help us understand how a networking device works simply by comparing its functionality to an equivalent working device in the reference model. 

\section{The OSI Model}
The \textbf{OSI(\textit{Open Systems Interconnect})} model is used to categorize or classify network components. It consists of 7 layers - each dealing with a specific type of functionality that a networking device must perform to meet its goal. Thus, certain devices operate primarily on one particular layer of the OSI model. For example, switches \textit{live} (i.e., primarily operate on) Layer 2 of the OSI model while routers live on Layer 3. 

The layers of the OSI model are stacked with the lower layers at the bottom, with Layer 1 at the base. Each layer interfaces with both the layers above and below it and passes them \textit{data} in the format that they're expecting. 

\subsection{Terminology related to the OSI Model}

To understand the different layers of the OSI stack, we first need to understand some basic terminology and devices:

\noindent
\begin{tabular}{rM{0.73}}
	\toprule
	\textbf{Terms} &\textbf{Description} \\
	\midrule
	\textbf{Ethernet Switch}	&A device which allows data to flow between multiple computers in a network and only sends the data to the correct device by the use of a physical address.\\
	\midrule
	\textbf{Physical Address}	&A \textbf{Layer-2} address \textit{burned into} (programmed within) the Network Interface Card (\textbf{NIC}) via which the computer is connected to the Network.\\
	\bottomrule
\end{tabular}

\noindent
\begin{tabular}{rM{0.75}}
	\toprule
	\textbf{Terms} &\textbf{Description} \\
	\midrule
	\textbf{NIC}	&A \textbf{NIC(\textit{Network Interface Card})} is a physical device which is used to connect to the network and has physical interfaces (ports) for wired mediums. \\
	\midrule
	\textbf{MAC Address}	&In a PC, this physical address burned into the NIC is called the \textbf{MAC (\textit{Media Access Control})} address. It's a 48-bit address typically written in Hexadecimal.\\
	\midrule
	\textbf{Logical Address}	&A logical address is an address that's assigned to a device by an external agent (such as a DHCP server) for the primary purpose of routing data within the network and among devices.\\
	\midrule
	\textbf{IP Address}	&The IP Address (i.e., the \textbf{IPv4 (\textit{Internet Protocol version 4})} address is a 32-bit logical address used by Layer-3 devices such as routers.\\
	\midrule
	\textbf{TCP}	&The \textbf{TCP \textit{(Transmission Control Protocol)}} is a framework or set of rules or method to send data from one device to another that's reliable because the receipt of data is acknowledged by the recipient.\\
	\midrule
	\textbf{UPD}	&The \textbf{UDP \textit{(User Datagram Protocol)}} is a similar protocol to TCP, buUt doesn't acknowledge the receipt of data and thus data loss in transit is possible, making it less reliable, but faster. \\
	\bottomrule
\end{tabular}

\subsection{The 7 layers of the OSI Model}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{"Mod1/chapters/1.1.a OSI Stack"}
	\caption{OSI Stack}
	\label{fig:1 OSI Stack}
\end{figure}

\noindent
\begin{tabular}{rM{0.75}}
	\toprule
	\textbf{Terms} &\textbf{Description} \\
	\midrule
	\textbf{Physical Layer}	&This layer is concerned with actually sending the bits (0s \& 1s) through the physical media (i.e, wires like Ethernet cable or via wireless mediums). It deals with a way to \textit{electrically} represent them (in case of copper wire based mediums) or \textit{optically} represent them (in case of fiber optics), etc. \\
	\midrule
	\textbf{Data-Link Layer}	&Layer-2 devices make forwarding decisions based on a physical address. An Ethernet switch in its basic form is a Layer-2 device. It makes forwarding decisions (i.e, where to send the incoming data) on the basis of a \textbf{physical} address, such as the 48-bit MAC Addresses in case of PCs.\\
	\bottomrule
\end{tabular}

\noindent
\begin{tabular}{rM{0.71}}
	\toprule
	\textbf{Terms} &\textbf{Description} \\
	\midrule
	\textbf{Network Layer}	&Layer-3 devices such as a router make forwarding decisions based on a \textbf{logical} Address such as the IP addresses of the machines in the network. A router analyzes the incoming data on it's ports and determines where to send the data next by finding out which of its other ports lead to the destination IP address.\\
	\midrule
	\textbf{Transport Layer}	&The TCP and UDP protocols operate on this layer, and determine how the data is transmitted over the network.\\
	\midrule
	\textbf{Session Layer}	&Sets up, maintains and tears down sessions. E.g., \textbf{SIP (\textit{Session Initiation Protocol})} used by IP phones for VoIP calls. \\
	\midrule
	\textbf{Presentation Layer}	&Deals with how data is represented on the network. For example, data may be encoded in ASCII (American Standard Code for Information Interchange) or UTF-8(Unicode Transformation Format 8-bit), etc. \textbf{Encryption} is also performed within this layer.\\
	\midrule
	\textbf{Application Layer}	&The name of this layer is a bit misleading since it is not any application which lives on this layer, but a Network service that allows other desktop applications to take advantage of that service. E.g., The Microsoft Active Directory (AD) service provides the end-user applications with the functionality of logging in to the AD via the network.\\
	\bottomrule
\end{tabular}

\noindent
Note that it's perfectly possible for a devices to operate in more than one layers, and it's not required to neatly arrange a device or protocol in a single layer. The OSI model is like a book shelf. Similar devices and protocols are arranged in a layer but just like it's possible to have empty shelves in a book-shelf, there's no necessity for a networking device/protocol to have a component present in every single layer. 

Since this stack forms the basis of all discussions in the domain of Networking, it's important to memorize the list of the components of the OSI stack and understand what each of the layers in the stack does. If we want to remember the names of the layers from Layer 7 downwards, the acrostic \textit{\textbf{A}ll \textbf{P}eople \textbf{S}eem \textbf{T}o \textbf{N}eed \textbf{D}ata \textbf{P}rocessing} can be helpful. To remember from bottom-up, the acrostic is: \textit{\textbf{P}lease \textbf{D}o \textbf{N}ot \textbf{T}hrow \textbf{S}ausage \textbf{P}izza \textbf{A}way}. 

An important point to remember is that the OSI model was \textbf{designed} to be \textit{generic} and comprehensive, to act as a reference model for more protocols than just IP. While IP can have certain features that live on certain layers, that's just not universally true for other protocols. Most of our networks run on the \textbf{TCP/IP(\textit{Transmission Control Protocol/Internet Protocol})} stack or the \textbf{DoD (\textit{Department of Defence})} stack. 

\section{TCP/IP Stack}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.55\linewidth]{"Mod1/chapters/1.1.b TCP-IP Stack"}
	\caption{TCP/IP Stack}
	\label{fig:1 TCP/IP Stack}
\end{figure}

The \textbf{TCP/IP(\textit{Transmission Control Protocol/Internet Protocol})} stack or the \textbf{DoD (\textit{Department of Defence})} model is another reference model that deals directly with the TCP/IP protocols and have a direct mapping to the layers in the OSI stack. This stack was created by the United States Dept. of Defence (DoD) and is thus named after it. 

\noindent
\begin{tabular}{rM{0.69}}
	\toprule
	\textbf{Terms} &\textbf{Description} \\
	\midrule
	\textbf{Network Access Layer}	&Corresponds to the Physical and Data-link layers of the OSI stack. It's concerned with addressing via physical addresses as well as the representation of the data on physical mediums such as cables. Another name for this layer is the \textbf{Network Interface} or the \textbf{Link} layer.\\
	\midrule
	\textbf{Internet Layer}	&Corresponds to the Network Layer of the OSI stack and deals with logical addressing via the IPv4 and IPv6 protocols.\\
	\midrule
	\textbf{Transport Layer}	&This is the equivalent of the Transport Layer of the OSI stack and also deals with the same function of determining the mode of transport, i.e., the protocol to be used for data transmission.\\
	\midrule
	\textbf{Application Layer}	&This is the equivalent layer to the combination of the Application, Presentation and Session layers of the OSI stack, and performs all their functions. \\
	\bottomrule
\end{tabular}

\noindent
Note that some literature that discusses the DoD stack show it as a 5-layer model with the bottom Network Access Layer sub-divided into Data-link and Physical layers:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\linewidth]{"Mod1/chapters/1.1.c DoD Alternate Model"}
	\caption{TCP/IP Stack Alternate Model}
	\label{fig:1 TCP/IP Stack Alternate Model}
\end{figure}

\noindent
Some may even choose to call this Data-link layer in the TCP/IP stack as the Network Interface Layer. Irrespective of the naming, the functioning of these layers remain consistent. 

\section{TCP/IP Protocol Suite}
The TCP/IP protocol suite consists of \textbf{IP, ICMP, TCP} and \textbf{UDP} protocols. In Layer 3, the Network layer of the OSI stack or the Internet layer of the TCP/IP stack, some of the most useful protocols are IP and ICMP.

\textbf{IP (\textit{Internet Protocol})} is used to forward \textit{packets} of data to the right (intended) recipient. \textbf{ICMP (\textit{Internet Control Message Protocol})} is used to test the reachability of remote network devices by \textit{pinging} them and can also report error conditions in a network. 

\subsection{Layer-3 (Network/Internet Layer) Protocols}
\subsubsection{Internet Protocol (IP)}
IP is a protocol which contains the data of other higher layer protocols as it's payload. Thus, it's payload consists of segments from UDP or TCP that need to be encapsulated within IP packets to be correctly formatted and sent over the network. Thus, routers, which are layer-3 devices can make forwarding decisions based on the logical address (destination IP address) packed by following the Internet Protocol. 

\subsubsection{ICMP}
A really common use of the \textbf{ICMP (\textit{Internet Control Message Protocol})} is to perform \textit{pings}. The \textbf{ping} utility is used to test if one network device is reachable from another network device. 

\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\linewidth]{"Mod1/chapters/1.1.d ICMP example"}
	\caption{Pings using ICMP}
	\label{fig:1 Pings using ICMP}
\end{figure}

\noindent
Let us consider the scenario above. A PC is connected to a switch which in turn is connected to a router. The switch, a layer-2 device, has two connections - one to the Ethernet port on the PC, which has a MAC address and another to the router's port, which also has it's own MAC address. These MAC addresses (and which port on the switch they're connected to) are known to the switch, which is how it makes forwarding decisions and facilitates the transmission of data. 

Now, if the PC can't connect to the internet, during the troubleshooting, one of the first things that we do is to check if we can \textit{reach} the next hop router (the router that connects us to everybody else on the internet/network) from the PC. For this we can use a utility called \textbf{ping} that's built into most \textbf{OS (\textit{Operating Systems})}. When ping is used, the PC sends out an \textbf{ICMP Echo Request} to that router's IP address. If the router receives that echo request (and if the settings permit it), the router then sends an \textbf{ICMP Echo Reply} back to the PC. 

The PC can then display that the router is reachable and tell us the \textit{round-trip time}, i.e., the amount of time it took for the packet to reach the router from the PC and then for the ICMP echo reply to acknowledge connectivity to reach the PC. 

If our \textbf{next-hop router} or our \textbf{default gateway}, i.e., the devices that connects us to the rest of the network, has an IP address of \verb|10.10.30.1|, we could ping it from the command line using (The \verb|-c| option specifies the number of \textit{ICMP echo requests} to send.):

\begin{minted}{console}
# ping -c 4 10.10.90.1
PING 10.10.90.1 (10.10.90.1) 56(84) bytes of data.
64 bytes from 10.10.90.1: icmp_seq=1 ttl=64 time=2.06 ms
64 bytes from 10.10.90.1: icmp_seq=2 ttl=64 time=1.31 ms
64 bytes from 10.10.90.1: icmp_seq=3 ttl=64 time=1.42 ms
64 bytes from 10.10.90.1: icmp_seq=4 ttl=64 time=3.37 ms

--- 10.10.90.1 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3004ms
rtt min/avg/max/mdev = 1.313/2.044/3.377/0.821 ms	
\end{minted}

\subsection{Layer-4 (Transport Layer) Protocols}
\subsubsection{User Datagram Protocol (UDP)}
\textbf{UDP} is a connection-less and unreliable protocol, because it doesn't receive acknowledgments for the segments that it transmits. While sending a UDP segment, while we hope that it reaches its destination, there's no guarantee that the data will reach the recipient. Further, there's no retransmission for data that failed to reach the destination because we don't know which data was received and which wasn't. 

Thus, UDP is used for real-time network applications such as in VoIP phones, where it's not important that every segment of data reach the destination, but the speed at which the segments flow is important. This is applicable for VoIP since we don't care if there's a slight stutter, but delay in communications (such as lag in voice and video, etc.) is unacceptable. Further, the use of TCP in such an application would be an extra overhead that would cause further delays, since a TCP header is much larger than the header on an UDP segment. Another reason TCP isn't used for VoIP is because even if a dropped segment is retransmitted, it may (and probably will) arrive out of order and is thus useless. 

\subsubsection{Transmission Control Protocol (TCP)}
\textbf{TCP} is a connection-oriented protocol that's reliable since it can detect if segments are \textit{dropped}, i.e., lost in transit. In TCP, a \textbf{connection} is set up between the two parties involved in the communication and then the data transfer occurs, with acknowledgement for each of the segments received from the recipient to the sender. 

A \textbf{Three-way handshake} is performed by the two-parties involved to establish a TCP connection. The steps involved are:

\begin{itemize}
	\item The sender sends a \textbf{SYN} (Synchronization message) to indicate that the sender wants to set up a \textit{session}. 
	\item The receiver now needs to send back a \textbf{SYN+ACK} message, i.e., acknowledge the \verb|SYN| message from the sender and then send a \verb|SYN| message of its own to the sender. 
	\item The final step in the 3-way handshake is for the sender to reply to the \verb|SYN| message from the recipient. 
\end{itemize}

\noindent
Now the TCP session is set up. One feature of TCP is that we can send varying amounts of data before expecting an acknowledgement, called TCP windowing.

\subsubsection{Sliding Window Protocol \& TCP Windowing}
TCP's sliding window protocol deals with its ability to vary the amount of data that a sender can send before expecting an acknowledgement. If we're on a highly reliable network, it'd be prudent to send more data at one time before expecting an acknowledgement, because there's less time wasted waiting for acknowledgement. This is called having a \textit{larger window size}. TCP can try to exponentially grow that window size. Let us consider the following case:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{"Mod1/chapters/1.1.e Sliding Window"}
	\caption{TCP's Sliding Window Protocol}
	\label{fig:1 TCP's Sliding Window Protocol}
\end{figure}

\noindent
Let us consider the laptop on the left is trying to communicate with the server on the right. After the three-way handshake is complete, the laptop sends the first segment of data. The server responds to this with and acknowledgement, and asks for the next segment, with \textbf{ACK 2}. The laptop now doubles the number of segments that it sends to 2. The server again responds with an acknowledgement, and demands segment 4 with \verb|ACK 4|. Once more the laptop doubles the number of segments it sends, this time to 4. The server, again responds with \verb|ACK 8|. 

This doubling continues till no acknowledgement is received from the server. When that happens, the laptop realizes that it's sending data too aggressively. This might mean that either a packet was dropped, or maybe the sender needs to wait longer for the acknowledgement. Now the sender (i.e., laptop) is going to drop its window size back down and grow at a slower rate, much more cautiously. 

\section{Domain Name System (DNS)}
Websites are content hosted on a server accessible by connecting to the IP address of a server (on the port on which the web-server is running). Thus, each public website on the internet has its own public IP. We could connect to the website using its IP, but it's impossible to remember the IPs for such a large number of websites. This is why we have domain names - an organized way to store information about websites. Domain names are hierarchical in nature for ease of indexing and categorization. To connect to a website, we can use its \textbf{FQDN (\textit{Fully Qualified Domain Name})}, a complete domain name specifying each level in that server's DNS hierarchy, instead of its IP. The job of a \textbf{DNS (\textit{Domain Name System})} server is to map each FQDN to an IP address to which our host machine can connect.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{"Mod1/chapters/1.1.f DNS"}
	\caption{DNS lookup}
	\label{fig:1 DNS Lookup}
\end{figure}

\noindent
Let us consider the PC above. It has the IP address of the DNS server set - either through manual settings or via the settings provided by DHCP. If we try to go to \verb|kwtrain.com| on the PC, a DNS query is issued to lookup its IP. The query reaches port 53 on the DNS server, which either passes on the IP address if previously saved on it, or performs a recursive lookup on other DNS servers till the IP address is found. Now the client PC can send HTTP/HTTPS data to the web server and the web server can respond with the requested data. 

\subsection{Well-known Port}
In a single session between two networking devices, there's a source port and a destination port number present. These ports act as the source of the incoming data/input and the port to which the output is sent. The port numbers in the range \textbf{0 - 1023} are called well-known ports, and common protocols such as DNS are assigned a port number in this range. DNS is assigned the port number 53 by default. 

\subsection{Hierarchical DNS Structure}
There isn't just one centralized master DNS server that handles all DNS queries, but a distributed system responsible for handling the queries in their DNS zones. There are several different root or \textbf{TLD (\textit{Top Level Domains})} such as \verb|.com| and \verb|.edu|, the IP addresses of which are known to the \textbf{root name server}. 

Whenever a new unknown domain is queried, a DNS server checks its cache for any name server that might lead it to the queried name server. For example, if we want to go to \verb|science.purdue.edu|, then our DNS server checks it's caches. If it can't find the DNS record for \verb|science.purdue.edu|, it tries to check if the DNS record for \verb|.edu| zone's name server is in it's cache. 

If not, since \verb|.edu| is a TLD, it queries the root name server for \verb|purdue.edu|'s IP. This is the first step in a recursive lookup process, where the DNS server queries each successive domain zone's server for the next domain till the required DNS record has been found. So, once the DNS server has the IP for the name server responsible for \verb|purdue.edu|, it will query it for the \verb|science.purdue.edu| and once it has it, the result will be returned to the host which originally asked for it. 

\begin{figure}[H]
	\centering
	\includegraphics[width=\linewidth]{"Mod1/chapters/1.1.g. Hierarchial DNS"}
	\caption{DNS Hierarchy}
	\label{fig:1 DNS Hierarchy}
\end{figure}


\subsection{DNS Record Types}
A DNS server or a name server doesn't simply map FQDNs to IP addresses, but has a database of several types of records:

\noindent
\begin{tabular}{rM{0.85}}
	\toprule
	\textbf{Terms} &\textbf{Description} \\
	\midrule
	\textbf{A}	&An \textbf{Address Record} is used to map a hostname to an IPv4 Address.\\
	\midrule
	\textbf{AAAA}	&An \textbf{IPv6 Address Record} is used to map a hostname to an IPv6 Address. There are 4 A's in the name because an IPv6 Address is 128-bits, i.e., 4 times as long as a 32-bit IPv4 Address.\\
	\midrule
	\textbf{CNAME}	&A \textbf{Canonical Name Record} is an alias of an existing record, which allows the DNS records for multiple hostnames to map to the same IP Address.\\
	\midrule
	\textbf{MX}	&A \textbf{Mail eXchange} record maps a domain name to an e-mail (or message transfer agent) server for that domain.\\
	\midrule
	\textbf{PTR}	&A \textbf{Pointer} record points to a canonical name. It's used to perform \textit{reverse DNS lookups} where we find the domain name associated with a known IP address.\\
	\midrule
	\textbf{SOA}	&A \textbf{Start of Authority} record provides authoritative information about a DNS Zone, such as email contact information for the zone's administrator, the zone's primary name server and various refresh timers. Further, when an SoA record is found, we know that the name server responsible for that zone itself is providing the information we need.\\
	\bottomrule
\end{tabular}

\subsection{Dynamic DNS (DDNS)}
It might be the case that our server is hosted with a dynamic IP, acquired from a DHCP server from our ISP. This means that the IP is bound to change periodically. Normally this'd mean that our DNS records would need to be \textit{manually} updated too, to reflect the changes and ensure that the lookup process isn't broken, but that's unnecessary with \textbf{DDNS (\textit{Dynamic DNS})}.

In DDNS, a software (\textit{DDNS service provider}) on the network monitors the changing IP address for an associated hostname, and once a change it detected, it automatically updates the DNS records for that hostname in the DNS tables in the name server responsible for the zone in which our host resides. From this point, further queries from other name servers propagate the new DNS record. Thus, the FQDN is always mapped to the right IP address. 

\section{Ports and Protocols}
The TCP and UDP protocols, both residing on Layer-4 of the OSI or DoD stack, are designed to encapsulate and carry the data payload for our applications, i.e., the data sent from Layer-5 or above through the network. 

Frequently, multiple applications are running on a single server with a given IP address. For example, a server may host applications that allow it to act as both the web server and the FTP server for a domain. If we try to access a web page in that domain, a query from our computer is sent to the server demanding the relevant info encapsulated within a TCP segment. 

When this segment reaches the destination server, there needs to be a way for the server to tell if the data within the segment is meant for the web server or the FTP server. This is why these applications are associated with a \textbf{port number}. There are a set of standardized set of \textbf{well-known port numbers} that are the port numbers generally associated with applications, such as port 80 for HTTP, port 443 for HTTPS, port 53 for DNS, etc. 

However, there are also un-assigned ports that can be used by any application, which range from \textbf{1024} to \textbf{65535}. These are used by applications to send data to another application on the network and receive replies from them. 

\subsection{Communication using Ports}
Let us consider the situation below - a client with the IP \verb|10.1.1.1| wants to access a web-server on the IP \verb|172.16.1.2|. Since the application is a web-server, we know that the well-known port associated with is port \verb|80|. So, the packet containing the query to access information on the web server is sent to \verb|172.16.1.2:80| from the client by an application. Let's say the application uses the port \verb|1248|. Since the application is requesting information from a web-server, the TCP protocol is used. Thus, we can say the request is made to \textit{TCP port 80} on the web server. 

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{"Mod1/chapters/1.1.h Port Numbers"}
	\caption{Port Numbers}
	\label{fig:1 Port Numbers}
\end{figure}

\noindent
Now, when the query is processed by the web server and a reply is sent back to the client, the packet will have a source IP of \verb|172.16.1.2| from port \verb|80|, and the destination IP will be the origin of the request, i.e., IP of the client, \verb|10.1.1.1|. The reply will be sent to the same port on the client where the application that made the query is awaiting information, i.e., port \verb|1248|. 

\subsection{List of some Well-Known ports}
\begin{figure}[h]
	\centering
	\includegraphics[width=1\linewidth]{"Mod1/chapters/1.1.i Well Known Ports"}
	\caption{Well known ports}
	\label{fig:1 Well known ports}
\end{figure}

\subsection{FTP (File Transfer Protocol)}
The \textbf{FTP (\textit{File Transfer Protocol})} is used to transfer files over a network. For example, in an office if we want our supervisor to review a report that we wrote, but we're working remotely, then we could authenticate to our department's FTP server with our username and password, and upload the file. Then our supervisor can log in with his credentials, make any required changes or recommendations, and save it. Then we can pull the file back down from the FTP server, and view the changes.

Although there is an authentication in FTP, it's not secure because of the fact that the content as well as the username and password are sent over the network in an unencrypted (i.e., plain text) format and thus anyone snooping on our communications can get unauthorized access to our files. This problem is resolved using the \textbf{SFTP (\textit{Secure File Transfer Protocol})} instead, which uses FTP through a SSH tunnel. This is similar to SCP which copies file over the network within a SSH tunnel. 

\subsection{SSH (Secure SHell)}
The \textbf{SSH (\textit{Secure SHell})} Protocol is used to log on to other computers/network devices on the network and access files/configurations on them. It uses \textit{TCP port 22}, and it's a secure protocol, i.e., the information in the packets in the network layer are encrypted. 

\subsection{SMTP, IMAP and POP3}
The \textbf{SMTP (\textit{Simple Mail Transfer Protocol})} is used to \textbf{send} mail from our devices (PC, laptop, smart-phones, etc.) to a mail server for a domain from \textit{TCP port 25}, but to retrieve mail from our mail servers, we need a protocol like \textbf{IMAP4 (\textit{Internet Message Access Protocol v4})} [\textit{TCP port 143}] or \textbf{POP3 (\textit{Post Office Protocol v3})} [\textit{TCP port 110}]. 

A problem that arises frequently with POP3 is that when multiple devices are accessing the same mailbox, mails can go missing. This is because POP3 after downloading mails from the server and storing them on the local computer/device, POP3 deletes them from the mailbox, thus making them unavailable from other devices. 

\subsection{DNS}
The \textbf{DNS (\textit{Domain Name System})} servers use port 53 (either \textit{TCP port 53} or \textit{UDP port 53}, but can use both) to resolve Fully Qualified Domain Names (FQDN) to IP addresses. 

\subsection{TFTP}
The \textbf{TFTP (\textit{Trivial File Transfer Protocol})} is similar to FTP but doesn't require any authentication for file transfer, using \textit{UDP port 69}. It's typically used internally within a controlled environment to provide files for operations like \textbf{PXE boot} (i.e., network booting). 

\subsection{DHCP (Dynamic Host Configuration Protocol)}
The \textbf{DHCP (\textit{Dynamic Host Configuration Protocol})} is used by a computer/smart phone or any other network device boots up on the network and needs to be assigned an IP address. It then can request the DHCP server on the network (\textit{UDP port 67}) for an IP address, which the DHCP server gives to it, along with some added information, such as the subnet mask, the default gateway IP, the DNS server IP, etc. 

\subsection{HTTP, HTTPS}
The \textbf{HTTP (\textit{HyperText Transfer Protocol})} [\textit{TCP port 80}] and \textbf{HTTPS (\textit{HyperText Transfer Protocol - Secure})} [\textit{TCP port 443}] are used to access content on a web-server. Webpages on the internet are served from web-servers using of these two protocols. 

\subsection{NTP, SNTP}
The \textbf{NTP (\textit{Network Time Protocol})} is used by network devices to synchronize their internal clocks using a time server (\textbf{NTP Server}). The \textbf{SNTP (\textit{Simple Network Time Protocol})} does the same job as NTP, but uses a less complex algorithm that generates a output that is less precise. Both NTP and SNTP use UDP port 123. 

Both of the above protocols are especially useful for troubleshooting multiple devices, since if the clocks on multiple devices are synchronized, we can use the timestamps on them to determine if events might be correlated and/or if problems started on multiple devices at the exact same time (indicating the point of origin for the issues is external). 

\subsection{LDAP}
The \textbf{LDAP (\textit{Lightweight Directory Access Protocol})} uses \textit{TCP port 389}. It allows organizations to have a centralized repository of user information (username, password, email information, etc.) and multiple services can leverage this single database to provide a single sign on (SSO) system. 

\subsection{rsh}
The \textbf{rsh (\textit{remote shell})} protocol is used in *nix (UNIX, Linux, etc.) shells to remotely execute commands on other *nix hosts on \textit{TCP port 514}.

\subsection{RealTime Streaming Protocol (RTSP)}
The \textbf{RTSP (\textit{RealTime Streaming Protocol})} allows us to stream video content from a video server, using either \textit{TCP port 554} or \textit{UDP port 554}, allowing us to control the playback of the video coming from that server. 

\subsection{Microsoft's Remote Desktop Protocol (RDP)}
This protocol isn't strictly well-known in the sense that it's port number is \textit{TCP port 3389}, but it's still known industry-wide. It allows a user to view and control the desktop of a Microsoft Windows computer from another computer. 

\section{Protocol Data Units (PDU)}
A \textbf{PDU (\textit{Protocol Data Unit})} is the information that is transmitted as a single unit among peer entities, residing on the same layer in a computer network. This means if the sender sends a \textit{packet} of information in a certain format from it's layer-3, the recipient at the destination receives the same packet of information in the exact same format in its layer-3. Simply speaking, it's what we call data at a layer, specifically one among the bottom 4 layers of the OSI model. The PDUs for the layers of the OSI stack are:

\vspace{-5pt}
\begin{center}
	\begin{tabular}{rc}
		\toprule
		\textbf{Layer}	&\textbf{PDU}\\
		\midrule
		\textbf{Transport}	&\hspace{20pt}\textbf{TCP:} Segments; \hspace{5pt} \textbf{UDP:} Datagrams\\
		\textbf{Network}	&Packets\\
		\textbf{Data-link}	&Frames\\
		\textbf{Physical}	&Bits\\
		\bottomrule
	\end{tabular}
\end{center}
\vspace{-5pt}

\noindent
In the physical layer, we're concerned with sending data \textit{on the wire}, i.e., through a transmission medium in the form of bits. Hence, it's PDU is bits. In the data-link layer, we have switches, which make forwarding decisions based on the information in frames, which is it's PDU. Routers on the Network Layer transmit packets among themselves, which is the basis for its PDU. Further, the term \textbf{packet} is used to generically used to refer to traffic at any layer. At the Transport layer, TCP PDUs are called \textbf{Segments}, and UDP PDUs are called \textbf{Datagrams}. It's okay to refer to both as segments generically. 

An acrostic to remember the PDUs in a top-down fashion, i.e., from the Transport layer to the Physical layer is : \textit{\textbf{S}ome \textbf{P}eople \textbf{F}ear \textbf{B}irthdays}. To remember it in a bottom-up, i.e., from Physical to Transport layer, we use the acrostic \textit{\textbf{B}acon \textbf{F}rying \textbf{P}roduces \textbf{S}alivation}.
